# 외벽 점검

소요시간: NaN

작성일시: 24.03.07 13:59:41

출처: https://school.programmers.co.kr/learn/courses/30/lessons/60062

### 접근 방법
1st
- 19/25 (시간 초과)
- 시간 초과 뜰 것 예상했지만 구현은 해 보았다..
- 최소 친구 수를 구하는 문제이므로 같은 수의 친구라면 멀리 이동 가능한 친구를 채택하자.
- 취약 지점에서 출발하도록 하면 효율적이다. 친구를 1명부터 취약 지점 개수만큼 선택하여 친구 수에 따라 친구가 선택 가능한 취약 지점을 탐색해보자. 전부 탐색 완료했으면 친구 수 즉시 Return.
- 외벽 2개 길이만큼 이어붙여서 원형 형태의 외벽을 조사하는 효과를 내도록 했다.

2nd
- 친구의 이동 거리를 알고 취약 지점 간의 거리를 알기 때문에, 외벽을 하나씩 검사하지 않고 현재 선택된 친구의 시작점과 이동거리, 다음 취약 지점을 비교하면 탐색 비용을 줄일 수 있다.
- 1st에서는 탐색을 시작할 취약 지점의 순열을 구했지만, 2nd에서는 취약 지점만을 순회하기 위해 k명의 친구의 순열을 구하고 시작 지점을 달리 하여 전체 탐색이 가능한지 알아본다.

### 시간 복잡도 분석
친구 수 = N
시간복잡도 = O(N! * N^2)

### 새로 알게 된 것
.

### 주의할 점
현재의 친구 조합이 전체 취약 지점을 탐색할 수 있는지 시작점을 달리하여 조사하는 반복문을 구현하는데 시간이 다소 소요되었다.  
정해진 변수가 어느 것이며, 가변값이 무엇이 되어야 하는지 정리하고 그림을 그려 확인해보니 구현이 한결 편해졌다.

### 기타 코멘트
순열로 접근하여 모든 가능성을 조회하는 최초 접근은 좋았다!  
친구 리스트를 내림차순으로 정렬하여 최초 k명만 탐색 보내는 접근도 좋다.  
1st solution의 비효율은 무엇을 기준으로 탐색했을 때 더 효율적인지 고려하지 않은 것에서 기인했다고 본다.(외벽 전체를 찾지 말고, 취약 지점만 띄엄띄엄 탐색해도 됐었는데..)

```python
from itertools import permutations
from collections import defaultdict

def solution(n, weak, dist):
    wall = [False] * n
    for w in weak:
        wall[w] = True
    wall *= 2

    dist.sort(reverse=True)

    for fnum in range(1, len(dist)+1):
        for weakSet in permutations(weak, fnum):
            visitCheckHash = defaultdict(bool)
            cnt = 0
            for i in range(fnum):
                w = weakSet[i]
                howFar = dist[i]
                for pos in range(w, w+howFar+1):
                    if wall[pos] and not visitCheckHash[pos%n]:
                        visitCheckHash[pos%n] = True
                        cnt += 1
            if cnt == len(weak):
                return fnum
    return -1
```
```python
from itertools import permutations

def solution(n, weak, dist):
    weak2 = weak[:]
    for i in range(len(weak)):
        weak2.append(weak[i]+n)
    dist.sort(reverse=True)

    for fnum in range(1, len(dist)+1):
        for friends in permutations(dist[:fnum], fnum):
            for startIdx in range(len(weak)):
                fIdx = 0
                friendPos = startIdx
                for w2Idx in range(startIdx, startIdx + len(weak)):
                    if weak2[w2Idx] <= weak2[friendPos] + friends[fIdx]:
                        continue
                    fIdx += 1
                    friendPos = w2Idx
                    if fIdx == fnum:
                        break
                else:
                    return fnum
    return -1
```
